{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>This demo case demonstrates functionality in FRAM open-source modelling framework for running energy market models. </p> <p>The demo case is modelling of the present-day European power market using JulES open-source power market model. The case is based on openly available data from different data providers, such as the Norwegian Water Resources and Energy Directorate (NVE), ENTSOE-E and other data providers. Detailed information about the data sources and the dataset can be found in dataset repository.  </p> <p>Important! Modelling in this demo case is by no means meant to be realistic. It is only used for demonstration purposes and must not be used for real analyses or investment decisions. NVE does not stand for the assumptions or the model results in this demo. Users must be aware of possible errors and inaccuracies in the dataset. NVE is not liable for any direct or indirect losses as a result of the use of the demo or in connection with copying or further distribution of the information in the modelling in this demo.</p>"},{"location":"#features-in-fram-that-we-want-to-demonstrate-with-this-demo","title":"Features in FRAM that we want to demonstrate with this demo:","text":"<ul> <li>model-independent database and a solid database handling package that can be adjusted depending on your needs</li> <li>efficient processing of large data amounts </li> <li>smart and innovative system for data transformation for the given power market model </li> <li>easy aggregation and disaggregation using core model</li> <li>flexibility and modularity - FRAM can be extended and adjusted depending on your needs </li> <li>easy APIs</li> </ul> <p>Image \u00a9 Pixabay</p>"},{"location":"how_to_run_demo/","title":"How to run the demo","text":"<p>To run the demo you first need to set up paths in script demo_utils.py</p> <p>Path to the database. The database has already been installed for you when you installed pip install fram-demo. Check where the database was installed and set the path here.</p> <p>PATH_DB = Path(r\"path/to/your/database\") </p> <p>Path to demo folder. Can be any folder on your computer.</p> <p>DEMO_FOLDER = Path(\"path/to/your/demo/folder\") </p> <p>Path to Julia environment and Julia depot. Can be any folder. Julia is an open-source programming language and is used in this demo to run JuLES power market model in this demo and will be installed in this path. </p> <p>JULIA_PATH_ENV = Path(r\"path/to/julia/environment\")</p> <p>JULIA_PATH_DEPOT = Path(r\"path/to/julia/depot\") </p>"},{"location":"how_to_run_demo/#demo-case-steps","title":"Demo case steps","text":"<p>The demo consists of 6 steps. Between the steps there is an intermediate storage of data so that you can run the steps in different order if you want. </p> <p>Run the following steps:</p> <ol> <li> <p>populate_model.py - creates a new model object and populates it with data from the database. Saves the populated object as a pickle file.</p> </li> <li> <p>aggregate_model.py - aggregates data per country using node aggregator. Saves the aggregated object as a pickle file.</p> </li> <li> <p>solve_model.py - configures and solves JulES power market model for the base case. The same configuration is used for both base run and sensitivinty run in this demo. OBS! Not all JulES configurations are supported yet, contact FRAM team if you want to test your own configuration and get an error.</p> </li> <li> <p>sensitivity_run.py - runs a sensitivity case where CO2 price is scaled up by 20%. JulES configuration is the same.</p> </li> <li> <p>get_regional_volumes.py - gets results for production and demand from the model.</p> </li> <li> <p>plot_solution.py - visualizes results in a simple plot.</p> </li> <li> <p>write_results_to_h5.py - work in progress! will write results to h5 format in order to send them to the dashboard.</p> </li> <li> <p>run_dashboard.py - work in progress! will run the dashboard in a browser and visualize results from h5 files.</p> </li> </ol> <p>Denne siden er uferdig, s\u00e5 ikke klikk See description of the demo case to learn what countries and years are included into the model runs. </p>"},{"location":"reference/","title":"Code Reference","text":""},{"location":"reference/#framdemo","title":"<code>framdemo</code>","text":""},{"location":"reference/#framdemo.EventHandler","title":"<code>EventHandler</code>","text":"<p>Custom event handler to control display of demo output.</p>"},{"location":"reference/#framdemo.EventHandler.EventHandler","title":"<code>EventHandler</code>","text":"<p>Handle events from framcore.events.send_event.</p> Source code in <code>framdemo/EventHandler.py</code> <pre><code>class EventHandler:\n    \"\"\"Handle events from framcore.events.send_event.\"\"\"\n\n    def handle_event(self, sender: object, event_type: str, **kwargs: dict[str, object]) -&gt; None:\n        \"\"\"Try to handle event using rich.print. Use Python.print otherwise.\"\"\"\n        name = self._get_sender_name(sender)\n        try:\n            self._handle_event_using_rich(name, event_type, **kwargs)\n        except Exception:\n            if name:\n                print(name, event_type, kwargs)\n            else:\n                print(event_type, kwargs)\n\n    def _get_sender_name(self, sender: object) -&gt; str:\n        if inspect.isbuiltin(sender) or sender is None:\n            return \"\"\n        is_func = False\n        try:\n            path = Path(inspect.getfile(type(sender)))\n        except Exception:\n            path = Path(inspect.getfile(sender))\n            is_func = True\n        package = None\n        for parent in path.parents:\n            if parent.name in [\"framcore\", \"framdemo\", \"framdata\", \"framjules\"]:\n                package = parent.name\n                break\n        name = sender.__name__ if is_func else type(sender).__name__\n\n        try:\n            if not is_func:\n                caller_method_name = inspect.stack()[5].function\n                name = f\"{name}.{caller_method_name}\"\n        except Exception:\n            pass\n\n        return f\"{name}\" if package is None else f\"{package}.{name}\"\n\n    def _handle_event_using_rich(\n        self,\n        sender_name: str,\n        event_type: str,\n        **kwargs: dict[str, object],\n    ) -&gt; None:\n        import rich  # noqa: PLC0415\n\n        sender_color = \"blue\"\n        sender_string = f\"[{sender_color}]{sender_name}: [/{sender_color}]\" if sender_name else \"\"\n\n        if event_type in [\"info\", \"debug\", \"warning\", \"error\"]:\n            color = {\n                \"info\": \"yellow\",\n                \"debug\": \"green\",\n                \"warning\": \"magenta\",\n                \"error\": \"red\",\n            }[event_type]\n            message = kwargs[\"message\"]\n\n            rich.print(f\"[bold {color}]{event_type}: [/bold {color}]{sender_string}{message}\")\n            return\n\n        if event_type == \"display\":\n            color = \"cyan\"\n            message = kwargs[\"message\"]\n            obj = kwargs[\"object\"]\n            obj = \"\" if obj is None else obj\n            if isinstance(obj, dict):\n                digits_round = kwargs.get(\"digits_round\", 3)\n                obj = self._try_prettify(obj, digits_round)\n            rich.print(f\"[bold {color}]{event_type}: [/bold {color}]{sender_string}{message}\", obj)\n            return\n\n        color = \"cyan\"\n        rich.print(f\"[bold {color}]{event_type}: [/bold {color}]{sender_string}\", kwargs)\n\n    def _try_prettify(self, obj: dict, digits_round: int) -&gt; dict:\n        if self._has_len_1(obj):\n            copied_obj = deepcopy(obj)\n            try:\n                self._convert_len_1_to_float(copied_obj, digits_round)\n                return copied_obj\n            except Exception:\n                pass\n        return obj\n\n    def _has_len_1(self, obj: object) -&gt; bool:\n        if isinstance(obj, dict):\n            for some_value in obj.values():\n                return self._has_len_1(some_value)\n            return False\n        return self._is_len_1(obj)\n\n    def _is_len_1(self, obj: object) -&gt; bool:\n        try:\n            return len(obj) == 1\n        except Exception:\n            return False\n\n    def _convert_len_1_to_float(self, obj: object, digits_round: int) -&gt; None:\n        if isinstance(obj, dict):\n            for key, value in obj.items():\n                if isinstance(value, dict):\n                    self._convert_len_1_to_float(value, digits_round)\n                else:\n                    obj[key] = round(float(value[0]), digits_round)\n</code></pre>"},{"location":"reference/#framdemo.EventHandler.EventHandler.handle_event","title":"<code>handle_event(sender: object, event_type: str, **kwargs: dict[str, object]) -&gt; None</code>","text":"<p>Try to handle event using rich.print. Use Python.print otherwise.</p> Source code in <code>framdemo/EventHandler.py</code> <pre><code>def handle_event(self, sender: object, event_type: str, **kwargs: dict[str, object]) -&gt; None:\n    \"\"\"Try to handle event using rich.print. Use Python.print otherwise.\"\"\"\n    name = self._get_sender_name(sender)\n    try:\n        self._handle_event_using_rich(name, event_type, **kwargs)\n    except Exception:\n        if name:\n            print(name, event_type, kwargs)\n        else:\n            print(event_type, kwargs)\n</code></pre>"},{"location":"reference/#framdemo.dashboard_app","title":"<code>dashboard_app</code>","text":"<p>Simple demo dashboard app.</p>"},{"location":"reference/#framdemo.demo_1_download_dataset","title":"<code>demo_1_download_dataset</code>","text":""},{"location":"reference/#framdemo.demo_1_download_dataset.demo_1_download_dataset","title":"<code>demo_1_download_dataset() -&gt; None</code>","text":"<p>Download the FRAM demo dataset from zenodo to the demo folder and unzip zip files.</p> <ol> <li>Dataset zip file is downloaded from https://zenodo.org/records/17294467 using REST api.</li> <li>File is unzipped in the dataset folder. The file is unzipped in such a way that it skips the first directory level, so all the db_xx directories should    be placed in the same folder as the zip file was downloaded to.</li> <li>Zip file is deleted.</li> </ol> Source code in <code>framdemo/demo_1_download_dataset.py</code> <pre><code>def demo_1_download_dataset() -&gt; None:\n    \"\"\"\n    Download the FRAM demo dataset from zenodo to the demo folder and unzip zip files.\n\n    1. Dataset zip file is downloaded from https://zenodo.org/records/17294467 using REST api.\n    2. File is unzipped in the dataset folder. The file is unzipped in such a way that it skips the first directory level, so all the db_xx directories should\n       be placed in the same folder as the zip file was downloaded to.\n    3. Zip file is deleted.\n\n    \"\"\"\n\n    if du.DATASET_SOURCE is not None:\n        assert isinstance(du.DATASET_SOURCE, Path) and du.DATASET_SOURCE.is_dir()\n        import os\n        import shutil\n        from time import time\n        t = time()\n        send_info_event(demo_1_download_dataset, \"downloading dataset\")\n        os.makedirs(du.DEMO_FOLDER / \"database\", exist_ok=False)\n        for name in os.listdir(du.DATASET_SOURCE):\n            path = du.DATASET_SOURCE / name\n            send_info_event(demo_1_download_dataset, f\"{path}\")\n            if path.is_dir():\n                shutil.copytree(src=path, dst=du.DEMO_FOLDER / \"database\" / name)\n            else:\n                shutil.copyfile(src=path, dst=du.DEMO_FOLDER / \"database\" / name)\n        send_info_event(demo_1_download_dataset, f\"time download dataset {round(time() - t, 3)} seconds\")\n        return \n\n    local_dataset_folder: Path = du.DEMO_FOLDER / \"database\"\n\n    if local_dataset_folder.is_dir() and list(local_dataset_folder.iterdir()):\n        send_warning_event(demo_1_download_dataset, f\"Skipping download because there is already data in {local_dataset_folder}\")\n        return\n\n    zenodo_url = \"https://zenodo.org/\"\n    dataset_id = \"17294467\"\n    api_url = zenodo_url + \"api/records/\" + dataset_id + \"/files\"  # Insert ID of dataset\n    url = zenodo_url + \"records/\" + dataset_id\n\n    local_dataset_folder.mkdir(exist_ok=True, parents=True)\n    send_info_event(demo_1_download_dataset, f\"Downloading dataset from {url} (this might take a few minutes)\")\n    try:\n        response = requests.get(api_url)\n        files_data = response.json()\n\n        for file_info in files_data[\"entries\"]:\n            file_url = file_info[\"links\"][\"self\"]\n            if not file_url.endswith(\".zip\"):\n                continue\n            file_url = zenodo_url + file_url.split(zenodo_url + \"api/\")[1]\n            file_path: Path = local_dataset_folder / file_info[\"key\"]\n            if file_path.exists() and zipfile.is_zipfile(str(file_path)):  # for if the file already exists as a valid zip file.\n                send_info_event(demo_1_download_dataset, f\"Existing file {file_path} exists and is a valid zipfile. Skipping download.\")\n                continue\n\n            # Download the file\n            with requests.get(file_url, stream=True) as r:\n                r.raise_for_status()\n                with file_path.open(mode=\"wb\") as f:\n                    for chunk in r.iter_content(chunk_size=8192):\n                        f.write(chunk)\n\n    except requests.exceptions.RequestException as e:\n        message = f\"An exception occured during download of dataset from Zenodo: {e}\"\n        send_error_event(sender=demo_1_download_dataset, message=message, exception_type_name=str(type(e)), traceback=e.__traceback__)\n    send_info_event(demo_1_download_dataset, \"Dataset download finished.\")\n\n    _unzip_files_in_folder(local_dataset_folder)\n</code></pre>"},{"location":"reference/#framdemo.demo_2_populate_model","title":"<code>demo_2_populate_model</code>","text":""},{"location":"reference/#framdemo.demo_2_populate_model.demo_2_populate_model","title":"<code>demo_2_populate_model()</code>","text":"<p>Populate model.</p> <ol> <li>Create model.</li> <li>Use populator to fill model with data</li> <li>Save model to disk for use in upcoming demos.</li> <li>Display model content before and after population.</li> </ol> Source code in <code>framdemo/demo_2_populate_model.py</code> <pre><code>def demo_2_populate_model():\n    \"\"\"\n    Populate model.\n\n    1. Create model.\n    2. Use populator to fill model with data\n    3. Save model to disk for use in upcoming demos.\n    4. Display model content before and after population.\n    \"\"\"\n    from framcore import Model\n    from framdata import NVEEnergyModelPopulator\n\n    import framdemo.demo_utils as du\n\n    # create empty model\n    model = Model()\n\n    # register model content before populate (for display below)\n    before = model.get_content_counts()\n\n    # create populator connected to data source and\n    # use it to populate the model with data objects\n    populator = NVEEnergyModelPopulator(source=du.DEMO_FOLDER / \"database\", validate=True)\n    populator.populate(model)\n\n    # register model content after populate (for display below)\n    after = model.get_content_counts()\n\n    # save populated model to disk so we can use it later\n    du.save(model, path=du.DEMO_FOLDER / \"populated_model.pickle\")\n\n    # display how model was changed\n    du.display(\"Model content before populate:\", before)\n    du.display(\"Model content after populate:\", after)\n</code></pre>"},{"location":"reference/#framdemo.demo_3_solve_model","title":"<code>demo_3_solve_model</code>","text":""},{"location":"reference/#framdemo.demo_3_solve_model.demo_3_solve_model","title":"<code>demo_3_solve_model(num_cpu_cores: int)</code>","text":"<p>Solve model.</p> <ol> <li>Read populated model from populate model demo from disk.</li> <li>Aggregate power nodes in model to elspot areas.</li> <li>Create a JulES solver object.</li> <li>Configure JulES.</li> <li>Solve the model with JulES.</li> </ol> Source code in <code>framdemo/demo_3_solve_model.py</code> <pre><code>def demo_3_solve_model(num_cpu_cores: int):\n    \"\"\"\n    Solve model.\n\n    1. Read populated model from populate model demo from disk.\n    2. Aggregate power nodes in model to elspot areas.\n    3. Create a JulES solver object.\n    4. Configure JulES.\n    5. Solve the model with JulES.\n    \"\"\"\n    from datetime import timedelta\n\n    import numpy as np\n\n    from framcore import Model\n    from framcore.aggregators import HydroAggregator, NodeAggregator\n    from framcore.timeindexes import ModelYear, OneYearProfileTimeIndex, WeeklyIndex\n    from framcore.timevectors import ListTimeVector\n\n    from framjules import JulES\n\n    import framdemo.demo_utils as du\n\n    model_year = ModelYear(2025)\n    first_weather_year = 1995\n    num_weather_years = 3\n    weekly_index = WeeklyIndex(first_weather_year, num_weather_years)\n\n    # Read populated model from populate model demo from disk.\n    model: Model = du.load(du.DEMO_FOLDER / \"populated_model.pickle\")\n\n    # Aggregate power nodes in model to elspot areas.\n    node_aggregator = NodeAggregator(\"Power\", \"elspot\", model_year, weekly_index)\n    node_aggregator.aggregate(model)\n\n    # Make a release_capacity_profile to further restrict the release capacity of the aggregated hydropower plants.\n    values = np.array([0.93, 0.88, 0.89, 0.90])\n    timeindex = OneYearProfileTimeIndex(period_duration=timedelta(weeks=13), is_52_week_years=True)\n    release_capacity_profile = ListTimeVector(timeindex, values, unit=None, is_max_level=None, is_zero_one_profile=True)\n\n    # Aggregate hydro power plants in model to elspot areas.\n    #   HydroAggregator will create one run-of-river hydropower module and one reservoir hydropower module per elspot area.\n    #   We use different aggregations for Norway and for Sweden and Finland.\n    #   We use a ror_threshold of 0.6 for Norway and 0.38 for Sweden and Finland, which indicates what regulation factor\n    #       a hydropower plant must have to be grouped as a reservoir hydropower plant.\n    hydro_aggregator_norway = HydroAggregator(\n        \"EnergyEqDownstream\",\n        model_year,\n        weekly_index,\n        ror_threshold=0.6,\n        metakey_power_node=\"Country\",\n        power_node_members=[\"Norway\"],\n        release_capacity_profile=release_capacity_profile,\n    )\n    hydro_aggregator_norway.aggregate(model)\n\n    hydro_aggregator_sweden_finland = HydroAggregator(\n        \"EnergyEqDownstream\",\n        model_year,\n        weekly_index,\n        ror_threshold=0.38,\n        metakey_power_node=\"Country\",\n        power_node_members=[\"Sweden\", \"Finland\"],\n        release_capacity_profile=release_capacity_profile,\n    )\n    hydro_aggregator_sweden_finland.aggregate(model)\n\n    # Save aggregated model to disk so we can use it later\n    du.save(model, path=du.DEMO_FOLDER / \"aggregated_model.pickle\")\n\n    # Create a JulES solver object.\n    jules = JulES()\n\n    # ----- Configure JulES ------\n\n    # Get object to configure JulES\n    config = jules.get_config()\n\n    # Configure serial simulation of model_year over all weather years\n    config.set_simulation_mode_serial()\n    config.set_weather_years(first_weather_year, num_weather_years)\n    config.set_data_period(model_year)\n    config.set_simulation_years(first_weather_year, num_weather_years)\n\n    # JulES can use this many cpu cores\n    config.set_num_cpu_cores(num_cpu_cores)\n\n    # JulES shall write files to this folder\n    config.set_solve_folder(du.DEMO_FOLDER / \"base\")\n\n    # Get object to configure time resolution\n    time_resolution = config.get_time_resolution()\n\n    # 2-day clearing problem with 3-hour market periods and 2-day storage periods\n    time_resolution.set_clearing_market_minutes(3 * 60)\n    time_resolution.set_clearing_storage_minutes(2 * 24 * 60)\n    time_resolution.set_clearing_days(2)\n\n    # 1-day short term prognosis problem with 6-hour market periods and 1-day storage periods\n    time_resolution.set_short_market_minutes(6 * 60)\n    time_resolution.set_short_storage_minutes(24 * 60)\n    time_resolution.set_short_days(1)\n\n    # Configure medium and long term prognosis problem\n    # and long term storage end value problem\n    #   Total lookahead horizon must be at least 4 years\n    #   Long term storage periods should be around 6 weeks long\n    #   Medium term horizon should be around 26 weeks long\n    #   Long term horizon for end value problems should be around 3 years\n    time_resolution.set_target_lookahead_days(4 * 365)\n    time_resolution.set_target_long_storage_days(6 * 7)\n    time_resolution.set_target_med_days(26 * 7)\n    time_resolution.set_target_ev_days(3 * 365)\n\n    # JulES can wait this many days between calculation\n    # of opportunity cost of long term storage\n    config.set_skipmax_days(21)\n\n    # JulES shall use aggregated hydro power in price prognosis problems used to\n    # HydroAggregator will create one run-of-river hydro plant and one hydro plant\n    # with reservoir for each power market zone\n    # hydro_aggregator = HydroAggregator(\"EnergyEqDownstream\", model_year, weekly_index)\n    # config.set_short_term_aggregations([hydro_aggregator])\n\n    # JulES shall use EUR as currency (e.g. for prices)\n    config.set_currency(\"EUR\")\n\n    # JulES shall convert to these units for input and output\n    #   We set Power as default so all other energy commodities (35 more)\n    #   can use the same units as Power.\n    #\n    #   We must set units for Hydro and CO2 since these commodities\n    #   need different units than Power.\n    #\n    #   For CO2, we only need to set stock unit, because this commodity\n    #   is only used for exogenous nodes.\n    #\n    #   For more information about stock and flow, see: https://en.wikipedia.org/wiki/Stock_and_flow\n    config.set_commodity_units(commodity=\"Power\", stock_unit=\"GWh\", flow_unit=\"MW\", is_default=True)\n    config.set_commodity_units(commodity=\"Hydro\", stock_unit=\"Mm3\", flow_unit=\"m3/s\")\n    config.set_commodity_units(commodity=\"CO2\", stock_unit=\"t\")\n\n    # Install the git branch \"redesign_mfw\" for both JulES and TuLiPa\n    config.set_jules_version(jules_branch=\"master\", tulipa_branch=\"redesign_mfw\")\n\n    # Tell JulES where to find Julia and where to install JulES\n    if du.JULIA_PATH_EXE is not None:\n        config.set_julia_exe_path(du.JULIA_PATH_EXE)\n    config.set_julia_env_path(du.DEMO_FOLDER / \"julia_env\")\n    config.set_julia_depot_path(du.DEMO_FOLDER / \"julia_depot\")\n\n    # Solve the model with JulES\n    jules.solve(model)\n</code></pre>"},{"location":"reference/#framdemo.demo_4_modified_solve","title":"<code>demo_4_modified_solve</code>","text":""},{"location":"reference/#framdemo.demo_4_modified_solve.demo_4_modified_solve","title":"<code>demo_4_modified_solve(num_cpu_cores: int)</code>","text":"<p>Use same model as demo 3 except one change. Reuse solver settings.</p> <ol> <li>Read aggregated model from demo 3 from disk</li> <li>Read configured JulES solver used in demo 3 from disk</li> <li>Make a few configurations</li> <li>Increase demand in Norway with 20 percent</li> <li>Solve the modified model with JulES</li> </ol> Source code in <code>framdemo/demo_4_modified_solve.py</code> <pre><code>def demo_4_modified_solve(num_cpu_cores: int):\n    \"\"\"\n    Use same model as demo 3 except one change. Reuse solver settings.\n\n    1. Read aggregated model from demo 3 from disk\n    2. Read configured JulES solver used in demo 3 from disk\n    3. Make a few configurations\n    4. Increase demand in Norway with 20 percent\n    5. Solve the modified model with JulES\n    \"\"\"\n    from framcore import Model\n    from framcore.components import Demand\n    from framjules import JulES\n\n    # import code written only for this demo (common names and useful functions)\n    import framdemo.demo_utils as du\n\n    # read aggregated model from demo 3 from disk\n    model: Model = du.load(du.DEMO_FOLDER / \"aggregated_model.pickle\")\n\n    # read configured jules solver used in demo 3 from disk\n    jules: JulES = du.load(du.DEMO_FOLDER / \"base\" / \"solver.pickle\")\n\n    # Make a few configurations (where to save files and to reuse installation)\n    config = jules.get_config()\n    config.set_solve_folder(du.DEMO_FOLDER / \"modified\")\n    config.activate_skip_install_dependencies()\n    config.set_num_cpu_cores(num_cpu_cores)\n\n    # Increase demand in norwegian price areas with 20 percent\n    for value in model.get_data().values():\n        if isinstance(value, Demand) and value.get_node() in [\"NO1\", \"NO2\", \"NO3\", \"NO4\", \"NO5\"]:\n            value.get_capacity().scale(1.2)\n\n    # Solve the model with JulES\n    jules.solve(model)\n</code></pre>"},{"location":"reference/#framdemo.demo_5_detailed_solve","title":"<code>demo_5_detailed_solve</code>","text":""},{"location":"reference/#framdemo.demo_5_detailed_solve.demo_5_detailed_solve","title":"<code>demo_5_detailed_solve(num_cpu_cores: int)</code>","text":"<p>Use same model as demo 3 except with detailed hydro power instead of aggregated hydropower.</p> <p>Solve model. 1. Read populated model from populate model demo from disk. 2. Aggregate power nodes in model to elspot areas. 3. Read configured JulES solver from demo 3. 4. Make a few configurations (where to save files and to reuse installation) 5. Create hydro power aggregators and put them into JulES via config 6. Solve the model with JulES.</p> Source code in <code>framdemo/demo_5_detailed_solve.py</code> <pre><code>def demo_5_detailed_solve(num_cpu_cores: int):\n    \"\"\"\n    Use same model as demo 3 except with detailed hydro power instead of aggregated hydropower.\n\n    Solve model.\n    1. Read populated model from populate model demo from disk.\n    2. Aggregate power nodes in model to elspot areas.\n    3. Read configured JulES solver from demo 3.\n    4. Make a few configurations (where to save files and to reuse installation)\n    5. Create hydro power aggregators and put them into JulES via config\n    6. Solve the model with JulES.\n    \"\"\"\n    from datetime import timedelta\n\n    import numpy as np\n    from framcore import Model\n    from framcore.aggregators import HydroAggregator, NodeAggregator\n    from framcore.timeindexes import ModelYear, OneYearProfileTimeIndex, WeeklyIndex\n    from framcore.timevectors import ListTimeVector\n    from framjules import JulES\n\n    import framdemo.demo_utils as du\n\n    # Read populated model from populate model demo from disk.\n    model: Model = du.load(du.DEMO_FOLDER / \"populated_model.pickle\")\n\n    # read configured jules solver used in demo 3 from disk\n    jules: JulES = du.load(du.DEMO_FOLDER / \"base\" / \"solver.pickle\")\n\n    # Make a few configurations (where to save files and to reuse installation)\n    config = jules.get_config()\n    config.set_solve_folder(du.DEMO_FOLDER / \"detailed\")\n    config.activate_skip_install_dependencies()\n    config.set_num_cpu_cores(num_cpu_cores)\n\n    # get info from config needed for the next steps\n    model_year: ModelYear = config.get_data_period()\n    first_weather_year, num_weather_years = config.get_weather_years()\n    weekly_index = WeeklyIndex(first_weather_year, num_weather_years)\n\n    # Aggregate power nodes in model to elspot areas.\n    node_aggregator = NodeAggregator(\"Power\", \"elspot\", model_year, weekly_index)\n    node_aggregator.aggregate(model)\n\n    # The below is different from demo 3.\n    # In demo 3, we aggregate the input model here.\n    # Here, we give JulES the hydro aggregators. This way, JulES will use detailed hydropower\n    # in the simulation, and only use aggregated hydropower when estimating future prices\n    # (we need aggregated hydropower in this step of JulES. Whithout it, the simulation would take forever to finish.\n    # You can see for yourself by uncommenting\n    # config.set_short_term_aggregations([hydro_aggregator_norway, hydro_aggregator_sweden_finland])\n    # below. This line, which will trigger detailed hydropower in all of JulES)\n\n    # Make a release_capacity_profile to further restrict the release capacity of the aggregated hydropower plants.\n    values = np.array([0.93, 0.88, 0.89, 0.90])\n    timeindex = OneYearProfileTimeIndex(period_duration=timedelta(weeks=13), is_52_week_years=True)\n    release_capacity_profile = ListTimeVector(timeindex, values, unit=None, is_max_level=None, is_zero_one_profile=True)\n\n    # Aggregate hydro power plants in model to elspot areas.\n    #   HydroAggregator will create one run-of-river hydropower module and one reservoir hydropower module per elspot area.\n    #   We use different aggregations for Norway and for Sweden and Finland.\n    #   We use a ror_threshold of 0.6 for Norway and 0.38 for Sweden and Finland, which indicates what regulation factor\n    #       a hydropower plant must have to be grouped as a reservoir hydropower plant.\n    hydro_aggregator_norway = HydroAggregator(\n        \"EnergyEqDownstream\",\n        model_year,\n        weekly_index,\n        ror_threshold=0.6,\n        metakey_power_node=\"Country\",\n        power_node_members=[\"Norway\"],\n        release_capacity_profile=release_capacity_profile,\n    )\n\n    hydro_aggregator_sweden_finland = HydroAggregator(\n        \"EnergyEqDownstream\",\n        model_year,\n        weekly_index,\n        ror_threshold=0.38,\n        metakey_power_node=\"Country\",\n        power_node_members=[\"Sweden\", \"Finland\"],\n        release_capacity_profile=release_capacity_profile,\n    )\n    config.set_short_term_aggregations([hydro_aggregator_norway, hydro_aggregator_sweden_finland])\n\n    # Solve the model with JulES\n    jules.solve(model)\n</code></pre>"},{"location":"reference/#framdemo.demo_6_nordic_solve","title":"<code>demo_6_nordic_solve</code>","text":""},{"location":"reference/#framdemo.demo_6_nordic_solve.demo_6_nordic_solve","title":"<code>demo_6_nordic_solve(num_cpu_cores: int)</code>","text":"<p>Use same as demo 4, but here we only simulate nordic zones, using prices from demo 3 as exogenous prices.</p> <ol> <li>Read aggregated model from demo 3 from disk</li> <li>Filter dataset to only contain Nordic power market</li> <li>Read configured JulES solver used in demo 3 from disk</li> <li>Make a few configurations</li> <li>Increase demand in Norway with 20 percent</li> <li>Solve the modified model with JulES</li> </ol> Source code in <code>framdemo/demo_6_nordic_solve.py</code> <pre><code>def demo_6_nordic_solve(num_cpu_cores: int):\n    \"\"\"\n    Use same as demo 4, but here we only simulate nordic zones, using prices from demo 3 as exogenous prices.\n\n    1. Read aggregated model from demo 3 from disk\n    2. Filter dataset to only contain Nordic power market\n    3. Read configured JulES solver used in demo 3 from disk\n    4. Make a few configurations\n    5. Increase demand in Norway with 20 percent\n    6. Solve the modified model with JulES\n    \"\"\"\n    from framcore import Model\n    from framcore.components import Demand\n    from framcore.utils import isolate_subnodes\n    from framjules import JulES\n\n    # import code written only for this demo (common names and useful functions)\n    import framdemo.demo_utils as du\n\n    # read solved model from demo 3 from disk\n    model: Model = du.load(du.DEMO_FOLDER / \"base\" / \"model.pickle\")\n\n    # Filter dataset to only contain Nordic power market\n    # this will make price zones trading with the nordics\n    # exogenous, and price results from demo 3 will be used\n    # to represent the price in these zones\n    isolate_subnodes(model, \"Power\", \"NordicRegion\", [\"Inside\"])\n\n    # read configured jules solver used in demo 3 from disk\n    jules: JulES = du.load(du.DEMO_FOLDER / \"base\" / \"solver.pickle\")\n\n    # Make a few configurations (where to save files and to reuse installation)\n    config = jules.get_config()\n    config.set_solve_folder(du.DEMO_FOLDER / \"nordic\")\n    config.activate_skip_install_dependencies()\n    config.set_num_cpu_cores(num_cpu_cores)\n\n    # Increase demand in norwegian price areas with 20 percent\n    for value in model.get_data().values():\n        if isinstance(value, Demand) and value.get_node() in [\"NO1\", \"NO2\", \"NO3\", \"NO4\", \"NO5\"]:\n            value.get_capacity().scale(1.2)\n\n    # Solve the model with JulES\n    jules.solve(model)\n</code></pre>"},{"location":"reference/#framdemo.demo_7_get_data","title":"<code>demo_7_get_data</code>","text":""},{"location":"reference/#framdemo.demo_7_get_data.demo_7_get_data","title":"<code>demo_7_get_data()</code>","text":"<p>Writes results to h5 files that will be sent to dashboard.</p> Source code in <code>framdemo/demo_7_get_data.py</code> <pre><code>def demo_7_get_data():\n    \"\"\"Writes results to h5 files that will be sent to dashboard.\"\"\"\n    import numpy as np\n    import pandas as pd\n    import datetime\n\n    from framcore import Model\n    from framcore.aggregators import HydroAggregator, NodeAggregator\n    from framcore.components import HydroModule, Node\n    from framcore.events import send_info_event, send_warning_event\n    from framcore.expressions import get_level_value\n    from framcore.querydbs import CacheDB\n    from framcore.timeindexes import AverageYearRange, DailyIndex, ModelYear, ProfileTimeIndex\n    from framcore.utils import get_regional_volumes\n\n    from framjules import JulES\n\n    # import code written only for this demo (common names and useful functions)\n    import framdemo.demo_utils as du\n\n\n    # output file paths\n    h5_file_path_prices = du.DEMO_FOLDER / \"dashboard_prices.h5\"\n    h5_file_path_volumes = du.DEMO_FOLDER / \"dashboard_volumes.h5\"\n    h5_file_path_hydro = du.DEMO_FOLDER / \"dashboard_hydro.h5\"\n\n    # ==========================\n    # Section: Price data\n    # ==========================\n\n    # get all power nodes\n\n    solve_names = [\"base\", \"modified\", \"detailed\", \"nordic\"]\n\n    # read configured jules solver used in demo 3 from disk\n    jules: JulES = du.load(du.DEMO_FOLDER / solve_names[0] / \"solver.pickle\")\n\n    # get info from config\n    config = jules.get_config()\n    first_simulation_year, num_simulation_years = config.get_simulation_years()\n    currency = config.get_currency()\n    price_unit = f\"{currency}/MWh\"\n    price_time_resolution = \"Days\"\n    daily_index = DailyIndex(first_simulation_year, num_simulation_years)\n    data_period: ModelYear = config.get_data_period()\n    model_year = data_period.get_start_time().isocalendar().year\n\n    common_metadata_is_not_written = True\n    with pd.HDFStore(h5_file_path_prices, mode=\"w\") as store:\n        for solve_name in solve_names:\n            send_info_event(None, message=f\"Getting prices for solve {solve_name}\")\n\n            try:\n                model: Model = du.load(du.DEMO_FOLDER / f\"{solve_name}/model.pickle\")\n            except Exception:\n                send_warning_event(None, message=f\"Found no model for {solve_name}\")\n                continue\n\n            db = CacheDB(model)\n            data = db.get_data()\n\n            for key, value in data.items():\n                if isinstance(value, Node) and value.get_commodity() == \"Power\":\n                    sanitized_zone = key.replace(\" \", \"_\")\n                    store_key = f\"{solve_name}/{sanitized_zone}\"\n                    vector = value.get_price().get_scenario_vector(db, daily_index, data_period, price_unit)\n                    store.put(key=store_key, value=pd.DataFrame({\"value\": vector}))\n\n            if common_metadata_is_not_written:\n                store.root._v_attrs.global_metadata = {\n                    \"model_year\": model_year,\n                    \"weather_years\": list(\n                        range(first_simulation_year, first_simulation_year + num_simulation_years),\n                    ),\n                    \"currency\": price_unit,\n                    \"time_resolution\": price_time_resolution,\n                }\n                common_metadata_is_not_written = False\n\n    send_info_event(None, message=f\"Saved price data to {h5_file_path_prices}\")\n\n    # ==========================\n    # Section: Regional volumes\n    # ==========================\n    category_total = \"Total\"\n    with pd.HDFStore(h5_file_path_volumes, mode=\"w\") as store:\n        for solve_name in solve_names:\n            send_info_event(None, message=f\"Getting regional volumes for solve {solve_name}\")\n\n            try:\n                model: Model = du.load(du.DEMO_FOLDER / f\"{solve_name}/model.pickle\")\n            except Exception:\n                continue\n\n            db = CacheDB(model)\n            data = db.get_data()\n\n            regional_volumes = get_regional_volumes(\n                db,\n                commodity=\"Power\",\n                node_category=\"Country\",\n                production_category=\"HighLevelSource\",\n                consumption_category=\"TotalConsumption\",\n                data_period=data_period,\n                scenario_period=AverageYearRange(first_simulation_year, num_simulation_years),\n                unit=\"GWh/year\",\n            )\n\n            production = regional_volumes.get_production()\n            consumption = regional_volumes.get_consumption()\n            _import = regional_volumes.get_import()\n            export = regional_volumes.get_export()\n\n            for name, d in [(\"Production\", production), (\"Consumption\", consumption)]:\n                for country, category_data in d.items():\n                    sanitized_country = country.replace(\" \", \"_\")\n                    total = None\n                    for category, volume in category_data.items():\n                        sanitized_category = \"NA\" if category is None else category\n                        assert sanitized_category != category_total\n                        key = f\"{solve_name}/{sanitized_country}/{name}/{sanitized_category}\"\n                        store.put(key=key, value=pd.DataFrame({\"volume\": volume}))\n                        if total is None:\n                            total = volume\n                        else:\n                            np.add(total, volume, out=total)\n                    key = f\"{solve_name}/{sanitized_country}/{name}/{category_total}\"\n                    store.put(key=key, value=pd.DataFrame({\"volume\": total}))\n\n            for name, d in [(\"Import\", _import), (\"Export\", export)]:\n                for country, category_data in d.items():\n                    sanitized_country = country.replace(\" \", \"_\")\n                    total = None\n                    for trading_partner, volume in category_data.items():\n                        sanitized_trading_partner = trading_partner.replace(\" \", \"_\")\n                        key = f\"{solve_name}/{sanitized_country}/{name}/{sanitized_trading_partner}\"\n                        store.put(key=key, value=pd.DataFrame({\"volume\": volume}))\n                        if total is None:\n                            total = volume\n                        else:\n                            np.add(total, volume, out=total)\n                    key = f\"{solve_name}/{sanitized_country}/{name}/{category_total}\"\n                    store.put(key=key, value=pd.DataFrame({\"volume\": total}))\n\n    send_info_event(None, message=f\"Saved regional volume data to {h5_file_path_volumes}\")\n\n    # ==========================\n    # Section: Hydro data\n    # ==========================\n\n    countries = [\"Norway\", \"Sweden\", \"Finland\"]\n    with pd.HDFStore(h5_file_path_hydro, mode=\"w\") as store:\n        for solve_name in solve_names:\n            send_info_event(None, message=f\"Getting hydro volumes for solve {solve_name}\")\n\n            try:\n                model: Model = du.load(du.DEMO_FOLDER / f\"{solve_name}/model.pickle\")\n            except Exception:\n                continue\n\n            if solve_name != \"detailed\":\n                model.disaggregate()\n\n            node_aggregator = NodeAggregator(\"Power\", \"Country\", data_period, daily_index)\n            node_aggregator.aggregate(model)\n            hydro_aggregator = HydroAggregator(\"EnergyEqDownstream\", data_period, daily_index)\n            hydro_aggregator.aggregate(model)\n\n            db = CacheDB(model)\n\n            data = dict()\n            for country in countries:\n                data[country] = dict()\n                for category in [\"reservoir_volume\", \"reservoir_capacity\", \"production\", \"inflow\"]:\n                    data[country][category] = np.zeros(daily_index.get_num_periods(), dtype=np.float32)\n\n            for v in db.get_data().values():\n                if not isinstance(v, HydroModule):\n                    continue\n\n                # works since hydro module is aggregated to country\n                country = v.get_generator().get_power_node()\n\n                reservoir = v.get_reservoir()\n                if reservoir is not None:\n                    data[country][\"reservoir_volume\"] += reservoir.get_volume().get_scenario_vector(db, daily_index, data_period, \"Mm3\")\n                    data[country][\"reservoir_capacity\"] += reservoir.get_capacity().get_scenario_vector(db, daily_index, data_period, \"Mm3\")\n\n                production = v.get_generator().get_production()\n                data[country][\"production\"] += production.get_scenario_vector(db, daily_index, data_period, \"MW\")\n\n                inflow = v.get_inflow()\n                if inflow is not None:\n                    data[country][\"inflow\"] += inflow.get_scenario_vector(db, daily_index, data_period, \"m3/s\")\n\n            for country, area_data in data.items():\n                if float(area_data[\"reservoir_capacity\"].max()) == 0:\n                    area_data[\"reservoir_percentage\"] = area_data[\"reservoir_capacity\"]\n                else:\n                    area_data[\"reservoir_percentage\"] = area_data[\"reservoir_volume\"] / area_data[\"reservoir_capacity\"]\n\n            for country, area_data in data.items():\n                for key, vector in area_data.items():\n                    store.put(key=f\"{solve_name}/{country}/{key}\", value=pd.DataFrame({\"value\": vector}))\n\n    send_info_event(None, message=f\"Saved hydro data to {h5_file_path_hydro}\")\n\n\n    # detailed hydro data\n\n    # input solve name and file paths\n    solve_name = \"detailed\"\n\n    solve_dir = du.DEMO_FOLDER / solve_name\n    solver_path = solve_dir / \"solver.pickle\"\n    model_path = solve_dir / \"model.pickle\"\n\n    if not (solve_dir.is_dir() and solver_path.is_file() and model_path.is_file()):\n        return\n\n    # output file paths\n    output_file_path = du.DEMO_FOLDER / \"dashboard_detailed_hydro.h5\"\n\n    # get info from configured jules solver\n    jules: JulES = du.load(solver_path)\n    config = jules.get_config()\n    first_simulation_year, num_simulation_years = config.get_simulation_years()\n    currency = config.get_currency()\n    clearing_market_minutes = config.get_time_resolution().get_clearing_market_minutes()\n\n    # derive query inputs\n    data_period: ModelYear = config.get_data_period()\n    model_year = data_period.get_start_time().isocalendar().year\n    data_dim = ModelYear(model_year)\n    scen_dim_yr = AverageYearRange(first_simulation_year, num_simulation_years)\n    scen_dim_market = ProfileTimeIndex(first_simulation_year, num_simulation_years, period_duration=datetime.timedelta(minutes=clearing_market_minutes), is_52_week_years=False)\n\n    # get model\n    model: Model = du.load(du.DEMO_FOLDER / solve_name / \"model.pickle\")\n    db = CacheDB(model)\n    data = model.get_data()\n\n    # create module_df\n    send_info_event(demo_7_get_data, \"creating module_df\")\n    eneq_dict = dict()\n    rows = []\n    for key, value in data.items():\n        if not isinstance(value, HydroModule):\n            continue\n        generator = value.get_generator()\n        if generator is not None:\n            x = float(generator.get_production().get_scenario_vector(db, scen_dim_yr, data_dim, \"GWh/year\")[0])\n            rows.append((key, \"ProductionGWhPerYear\", x))\n        pump = value.get_pump()\n        if pump is not None:\n            x = float(pump.get_power_consumption().get_scenario_vector(db, scen_dim_yr, data_dim, \"GWh/year\")[0])\n            rows.append((key, \"PumpConsumptionGWhPerYear\", x))\n        reservoir = value.get_reservoir()\n        if reservoir is None:\n            continue\n        eneq = value.get_meta(\"EnergyEqDownstream\")\n        if eneq is None:\n            continue\n        eneq_kwh_per_m3 = get_level_value(eneq.get_value(), db, \"kWh/m3\", data_dim, scen_dim_yr, is_max=False)\n        if eneq_kwh_per_m3 &lt;= 0:\n            continue\n        eneq_dict[key] = eneq_kwh_per_m3\n        reservoir_cap_mm3 = float(reservoir.get_capacity().get_scenario_vector(db, scen_dim_yr, data_dim, \"Mm3\").max())\n        reservoir_cap_gwh = eneq_kwh_per_m3 * reservoir_cap_mm3\n        if reservoir_cap_mm3 &lt;= 0:\n            continue\n        # TODO: replace dummy data with hydro_module.get_scenario_vector call\n        water_value = 50\n        # water_value = value.get_water_value().get_scenario_vector(db, scen_dim_yr, data_dim, f\"{currency}/m3\")\n        water_value = water_value / eneq_kwh_per_m3 # EUR/m3 to EUR/kWh\n        water_value = water_value * 1000.0          # EUR/kWh to EUR/MWh\n        rows.append((key, \"ReservoirCapacityMm3\", reservoir_cap_mm3))\n        rows.append((key, \"ReservoirCapacityGWh\", reservoir_cap_gwh))\n        rows.append((key, \"EnergyEqDownstream\", eneq_kwh_per_m3))\n        rows.append((key, \"WaterValueEURPerMWh\", water_value))\n    modules_df = pd.DataFrame(rows, columns=[\"Module\", \"Type\", \"Value\"])\n\n    # find biggest reservoirs\n    send_info_event(demo_7_get_data, \"finding biggest reservoirs\")\n    biggest = modules_df.copy()\n    biggest = biggest[biggest[\"Type\"] == \"ReservoirCapacityGWh\"]\n    biggest = biggest.sort_values(by=\"Value\", ascending=False)\n    biggest = biggest.reset_index(drop=True)\n    biggest = list(biggest.iloc[:20][\"Module\"])\n\n    # find price area for each biggest reservoir\n    power_node_dict = dict()\n    for key in biggest:\n        next_key = key\n        power_node = None\n        while not power_node:\n            hydro_module: HydroModule = data[next_key]\n            generator = hydro_module.get_generator()\n            if generator is not None:\n                power_node = generator.get_power_node()\n                break\n            pump = hydro_module.get_pump()\n            if pump is not None:\n                power_node = pump.get_power_node()\n                break\n            next_key = hydro_module.get_release_to()\n        power_node_dict[key] = power_node\n\n    # get prices for each relevant power node\n    power_prices = dict()\n    for key in set(power_node_dict.values()):\n        node: Node = data[key]\n        price = node.get_price().get_scenario_vector(db, scen_dim_market, data_dim, f\"{currency}/MWh\")\n        power_prices[key] = price\n\n    # create series_df for the biggest reservoirs\n    send_info_event(demo_7_get_data, \"creating series_df for biggest reservoirs\")\n    series_df = dict()\n    for key in biggest:\n        hydro_module: HydroModule = data[key]\n        reservoir = hydro_module.get_reservoir()\n        eneq_kwh_per_m3 = eneq_dict[key]\n        reservoir_cap_mm3_series = reservoir.get_capacity().get_scenario_vector(db, scen_dim_market, data_dim, \"Mm3\")\n        reservoir_vol_mm3_series = reservoir.get_volume().get_scenario_vector(db, scen_dim_market, data_dim, \"Mm3\")\n        reservoir_filling = reservoir_vol_mm3_series / reservoir_cap_mm3_series\n        # TODO: replace dummy data with hydro_module.get_scenario_vector call\n        water_values = reservoir_filling.copy()\n        water_values.fill(50.0)\n        # water_values = hydro_module.get_water_value().get_scenario_vector(db, scen_dim_market, data_dim, f\"{currency}/m3\")\n        np.multiply(water_value, 1000.0 / eneq_kwh_per_m3, out=water_values)\n        series_df[f\"ReservoirFilling/{key}\"] = reservoir_filling\n        series_df[f\"WaterValueEURPerMWh/{key}\"] = water_values\n        series_df[f\"PowerPriceEURPerMWh/{key}\"] = power_prices[power_node_dict[key]]\n\n    series_df = pd.DataFrame(series_df)\n\n    # write result file\n    send_info_event(demo_7_get_data, f\"writing result file: {output_file_path}\")\n    with pd.HDFStore(output_file_path, mode=\"w\") as store:\n        store.put(key=\"modules_df\", value=modules_df)\n        store.put(key=\"series_df\", value=series_df)\n</code></pre>"},{"location":"reference/#framdemo.demo_8_run_dashboard","title":"<code>demo_8_run_dashboard</code>","text":""},{"location":"reference/#framdemo.demo_8_run_dashboard.demo_8_run_dashboard","title":"<code>demo_8_run_dashboard()</code>","text":"<p>Runs dashboard with results in your browser.</p> Source code in <code>framdemo/demo_8_run_dashboard.py</code> <pre><code>def demo_8_run_dashboard():\n    \"\"\"Runs dashboard with results in your browser.\"\"\"\n    import subprocess\n    import webbrowser\n    from pathlib import Path\n\n    def get_available_port() -&gt; int:\n        \"\"\"\n        Find an available local port by binding to port 0.\n\n        The operating system will assign a free port.\n        \"\"\"\n        import socket\n\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.bind((\"\", 0))  # Binds to an available port on all interfaces\n            return int(s.getsockname()[1])  # Returns the assigned port number\n\n    def get_streamlit_cmd_path() -&gt; Path | None:\n        \"\"\"Search sys.path and return first path to streamlit.cmd.\"\"\"\n        import sys\n        from collections.abc import Iterable\n\n        def _get_streamlit_cmd_path(paths: Iterable[Path]) -&gt; Path | None:\n            for path in paths:\n                if not path.is_dir() and path.name.lower() == \"streamlit.cmd\":\n                    return path\n                if path.is_dir():\n                    result = _get_streamlit_cmd_path(path.iterdir())\n                    if result is not None:\n                        return result\n            return None\n\n        return _get_streamlit_cmd_path(map(Path, sys.path))\n\n    def get_browser_exe_path() -&gt; Path:\n        \"\"\"Find a browser supported by streamlit.\"\"\"\n        import browsers\n\n        # safari is also supported by streamlit, but not findable with pybrowsers it seems\n        findable_and_supported_by_streamlit = [\"chrome\", \"msedge\", \"firefox\"]\n\n        browser_dicts = list(browsers.browsers())\n\n        browser_dicts = [d for d in browser_dicts if d[\"browser_type\"] in findable_and_supported_by_streamlit]\n\n        if not browser_dicts:\n            message = \"Was not able to automatically find a supported browser. Need chrome, msedge or firefox to run.\"\n            raise RuntimeError(message)\n\n        return browser_dicts[0][\"path\"]\n\n    current_folder = Path.resolve(Path(__file__)).parent\n    app_path = current_folder / \"dashboard_app.py\"\n\n    port = get_available_port()\n\n    # Open the Streamlit app in browser\n    webbrowser.register(\"streamlit_browser\", None, webbrowser.BackgroundBrowser(get_browser_exe_path()))\n\n    # Run the Streamlit app\n    streamlit_cmd = str(get_streamlit_cmd_path()) or \"streamlit\"\n    subprocess.run([streamlit_cmd, \"run\", str(app_path), \"--server.port\", str(port)], check=True)\n</code></pre>"},{"location":"reference/#framdemo.demo_utils","title":"<code>demo_utils</code>","text":"<p>Contains paths that may be set by users to override default behaviour.</p> <p>Contains constants and small utility functions to make the demos more robust and easier to follow.</p>"},{"location":"reference/#framdemo.demo_utils.display","title":"<code>display(message: str, obj: object = None, digits_round: int = 1) -&gt; None</code>","text":"<p>Send an object to EventHandler for display.</p> Source code in <code>framdemo/demo_utils.py</code> <pre><code>def display(message: str, obj: object = None, digits_round: int = 1) -&gt; None:\n    \"\"\"Send an object to EventHandler for display.\"\"\"\n    send_event(None, \"display\", message=message, object=obj, digits_round=digits_round)\n</code></pre>"},{"location":"reference/#framdemo.demo_utils.load","title":"<code>load(path: Path) -&gt; object</code>","text":"<p>Read object from pickle file.</p> Source code in <code>framdemo/demo_utils.py</code> <pre><code>def load(path: Path) -&gt; object:\n    \"\"\"Read object from pickle file.\"\"\"\n    with Path.open(path, \"rb\") as f:\n        return pickle.load(f)\n</code></pre>"},{"location":"reference/#framdemo.demo_utils.save","title":"<code>save(obj: object, path: Path) -&gt; None</code>","text":"<p>Write object to pickle file at given path.</p> Source code in <code>framdemo/demo_utils.py</code> <pre><code>def save(obj: object, path: Path) -&gt; None:\n    \"\"\"Write object to pickle file at given path.\"\"\"\n    if not path.parent.exists():\n        path.parent.mkdir(parents=True, exist_ok=True)\n    with Path.open(path, \"wb\") as f:\n        pickle.dump(obj, f)\n</code></pre>"},{"location":"reference/#framdemo.install_poetry","title":"<code>install_poetry</code>","text":"<p>This script will install Poetry and its dependencies in an isolated fashion.</p> It will perform the following steps <ul> <li>Create a new virtual environment using the built-in venv module, or the virtualenv zipapp if venv is unavailable.   This will be created at a platform-specific path (or <code>$POETRY_HOME</code> if <code>$POETRY_HOME</code> is set:<ul> <li><code>~/Library/Application Support/pypoetry</code> on macOS</li> <li><code>$XDG_DATA_HOME/pypoetry</code> on Linux/Unix (<code>$XDG_DATA_HOME</code> is <code>~/.local/share</code> if unset)</li> <li><code>%APPDATA%\\pypoetry</code> on Windows</li> </ul> </li> <li>Update pip inside the virtual environment to avoid bugs in older versions.</li> <li>Install the latest (or a given) version of Poetry inside this virtual environment using pip.</li> <li>Install a <code>poetry</code> script into a platform-specific path (or <code>$POETRY_HOME/bin</code> if <code>$POETRY_HOME</code> is set):<ul> <li><code>~/.local/bin</code> on Unix</li> <li><code>%APPDATA%\\Python\\Scripts</code> on Windows</li> </ul> </li> <li>Attempt to inform the user if they need to add this bin directory to their <code>$PATH</code>, as well as how to do so.</li> <li>Upon failure, write an error log to `poetry-installer-error-.log and restore any previous environment. <p>This script performs minimal magic, and should be relatively stable. However, it is optimized for interactive developer use and trivial pipelines. If you are considering using this script in production, you should consider manually-managed installs, or use of pipx as alternatives to executing arbitrary, unversioned code from the internet. If you prefer this script to alternatives, consider maintaining a local copy as part of your infrastructure.</p> <p>For full documentation, visit https://python-poetry.org/docs/#installation.</p>"},{"location":"reference/#framdemo.install_poetry.Cursor","title":"<code>Cursor</code>","text":"Source code in <code>framdemo/install_poetry.py</code> <pre><code>class Cursor:\n    def __init__(self) -&gt; None:\n        self._output = sys.stdout\n\n    def move_up(self, lines: int = 1) -&gt; \"Cursor\":\n        self._output.write(f\"\\x1b[{lines}A\")\n\n        return self\n\n    def move_down(self, lines: int = 1) -&gt; \"Cursor\":\n        self._output.write(f\"\\x1b[{lines}B\")\n\n        return self\n\n    def move_right(self, columns: int = 1) -&gt; \"Cursor\":\n        self._output.write(f\"\\x1b[{columns}C\")\n\n        return self\n\n    def move_left(self, columns: int = 1) -&gt; \"Cursor\":\n        self._output.write(f\"\\x1b[{columns}D\")\n\n        return self\n\n    def move_to_column(self, column: int) -&gt; \"Cursor\":\n        self._output.write(f\"\\x1b[{column}G\")\n\n        return self\n\n    def move_to_position(self, column: int, row: int) -&gt; \"Cursor\":\n        self._output.write(f\"\\x1b[{row + 1};{column}H\")\n\n        return self\n\n    def save_position(self) -&gt; \"Cursor\":\n        self._output.write(\"\\x1b7\")\n\n        return self\n\n    def restore_position(self) -&gt; \"Cursor\":\n        self._output.write(\"\\x1b8\")\n\n        return self\n\n    def hide(self) -&gt; \"Cursor\":\n        self._output.write(\"\\x1b[?25l\")\n\n        return self\n\n    def show(self) -&gt; \"Cursor\":\n        self._output.write(\"\\x1b[?25h\\x1b[?0c\")\n\n        return self\n\n    def clear_line(self) -&gt; \"Cursor\":\n        \"\"\"\n        Clears all the output from the current line.\n        \"\"\"\n        self._output.write(\"\\x1b[2K\")\n\n        return self\n\n    def clear_line_after(self) -&gt; \"Cursor\":\n        \"\"\"\n        Clears all the output from the current line after the current position.\n        \"\"\"\n        self._output.write(\"\\x1b[K\")\n\n        return self\n\n    def clear_output(self) -&gt; \"Cursor\":\n        \"\"\"\n        Clears all the output from the cursors' current position\n        to the end of the screen.\n        \"\"\"\n        self._output.write(\"\\x1b[0J\")\n\n        return self\n\n    def clear_screen(self) -&gt; \"Cursor\":\n        \"\"\"\n        Clears the entire screen.\n        \"\"\"\n        self._output.write(\"\\x1b[2J\")\n\n        return self\n</code></pre>"},{"location":"reference/#framdemo.install_poetry.Cursor.clear_line","title":"<code>clear_line() -&gt; Cursor</code>","text":"<p>Clears all the output from the current line.</p> Source code in <code>framdemo/install_poetry.py</code> <pre><code>def clear_line(self) -&gt; \"Cursor\":\n    \"\"\"\n    Clears all the output from the current line.\n    \"\"\"\n    self._output.write(\"\\x1b[2K\")\n\n    return self\n</code></pre>"},{"location":"reference/#framdemo.install_poetry.Cursor.clear_line_after","title":"<code>clear_line_after() -&gt; Cursor</code>","text":"<p>Clears all the output from the current line after the current position.</p> Source code in <code>framdemo/install_poetry.py</code> <pre><code>def clear_line_after(self) -&gt; \"Cursor\":\n    \"\"\"\n    Clears all the output from the current line after the current position.\n    \"\"\"\n    self._output.write(\"\\x1b[K\")\n\n    return self\n</code></pre>"},{"location":"reference/#framdemo.install_poetry.Cursor.clear_output","title":"<code>clear_output() -&gt; Cursor</code>","text":"<p>Clears all the output from the cursors' current position to the end of the screen.</p> Source code in <code>framdemo/install_poetry.py</code> <pre><code>def clear_output(self) -&gt; \"Cursor\":\n    \"\"\"\n    Clears all the output from the cursors' current position\n    to the end of the screen.\n    \"\"\"\n    self._output.write(\"\\x1b[0J\")\n\n    return self\n</code></pre>"},{"location":"reference/#framdemo.install_poetry.Cursor.clear_screen","title":"<code>clear_screen() -&gt; Cursor</code>","text":"<p>Clears the entire screen.</p> Source code in <code>framdemo/install_poetry.py</code> <pre><code>def clear_screen(self) -&gt; \"Cursor\":\n    \"\"\"\n    Clears the entire screen.\n    \"\"\"\n    self._output.write(\"\\x1b[2J\")\n\n    return self\n</code></pre>"},{"location":"reference/#framdemo.install_poetry.Installer","title":"<code>Installer</code>","text":"Source code in <code>framdemo/install_poetry.py</code> <pre><code>class Installer:\n    METADATA_URL = \"https://pypi.org/pypi/poetry/json\"\n    VERSION_REGEX = re.compile(\n        r\"v?(\\d+)(?:\\.(\\d+))?(?:\\.(\\d+))?(?:\\.(\\d+))?\"\n        \"(\"\n        \"[._-]?\"\n        r\"(?:(stable|beta|b|rc|RC|alpha|a|patch|pl|p)((?:[.-]?\\d+)*)?)?\"\n        \"([.-]?dev)?\"\n        \")?\"\n        r\"(?:\\+[^\\s]+)?\",\n    )\n\n    def __init__(\n        self,\n        version: str | None = None,\n        preview: bool = False,\n        force: bool = False,\n        accept_all: bool = False,\n        git: str | None = None,\n        path: str | None = None,\n    ) -&gt; None:\n        self._version = version\n        self._preview = preview\n        self._force = force\n        self._accept_all = accept_all\n        self._git = git\n        self._path = path\n\n        self._cursor = Cursor()\n        self._bin_dir = None\n        self._data_dir = None\n\n    @property\n    def bin_dir(self) -&gt; Path:\n        if not self._bin_dir:\n            self._bin_dir = bin_dir()\n        return self._bin_dir\n\n    @property\n    def data_dir(self) -&gt; Path:\n        if not self._data_dir:\n            self._data_dir = data_dir()\n        return self._data_dir\n\n    @property\n    def version_file(self) -&gt; Path:\n        return self.data_dir.joinpath(\"VERSION\")\n\n    def allows_prereleases(self) -&gt; bool:\n        return self._preview\n\n    def run(self) -&gt; int:\n        if self._git:\n            version = self._git\n        elif self._path:\n            version = self._path\n        else:\n            try:\n                version, current_version = self.get_version()\n            except ValueError:\n                return 1\n\n        if version is None:\n            return 0\n\n        self.display_pre_message()\n        self.ensure_directories()\n\n        def _is_self_upgrade_supported(x):\n            mx = self.VERSION_REGEX.match(x)\n\n            if mx is None:\n                # the version is not semver, perhaps scm or file\n                # we assume upgrade is supported\n                return True\n\n            vx = (*tuple(int(p) for p in mx.groups()[:3]), mx.group(5))\n            return vx &gt;= (1, 1, 7)\n\n        if version and not _is_self_upgrade_supported(version):\n            self._write(\n                colorize(\n                    \"warning\",\n                    f\"You are installing {version}. When using the current installer, \"\n                    \"this version does not support updating using the 'self update' \"\n                    \"command. Please use 1.1.7 or later.\",\n                ),\n            )\n            if not self._accept_all:\n                continue_install = input(\"Do you want to continue? ([y]/n) \") or \"y\"\n                if continue_install.lower() in {\"n\", \"no\"}:\n                    return 0\n\n        try:\n            self.install(version)\n        except subprocess.CalledProcessError as e:\n            raise PoetryInstallationError(\n                return_code=e.returncode,\n                log=e.output.decode(),\n            ) from e\n\n        self._write(\"\")\n        self.display_post_message(version)\n\n        return 0\n\n    def install(self, version):\n        \"\"\"\n        Installs Poetry in $POETRY_HOME.\n        \"\"\"\n        self._write(\n            \"Installing {} ({})\".format(\n                colorize(\"info\", \"Poetry\"),\n                colorize(\"info\", version),\n            ),\n        )\n\n        with self.make_env(version) as env:\n            self.install_poetry(version, env)\n            self.make_bin(version, env)\n            self.version_file.write_text(version)\n            self._install_comment(version, \"Done\")\n\n            return 0\n\n    def uninstall(self) -&gt; int:\n        if not self.data_dir.exists():\n            self._write(\n                \"{} is not currently installed.\".format(colorize(\"info\", \"Poetry\")),\n            )\n\n            return 1\n\n        version = None\n        if self.version_file.exists():\n            version = self.version_file.read_text().strip()\n\n        if version:\n            self._write(\n                \"Removing {} ({})\".format(\n                    colorize(\"info\", \"Poetry\"),\n                    colorize(\"b\", version),\n                ),\n            )\n        else:\n            self._write(\"Removing {}\".format(colorize(\"info\", \"Poetry\")))\n\n        shutil.rmtree(str(self.data_dir))\n        for script in [\"poetry\", \"poetry.bat\", \"poetry.exe\"]:\n            if self.bin_dir.joinpath(script).exists():\n                self.bin_dir.joinpath(script).unlink()\n\n        return 0\n\n    def _install_comment(self, version: str, message: str):\n        self._overwrite(\n            \"Installing {} ({}): {}\".format(\n                colorize(\"info\", \"Poetry\"),\n                colorize(\"b\", version),\n                colorize(\"comment\", message),\n            ),\n        )\n\n    @contextmanager\n    def make_env(self, version: str) -&gt; VirtualEnvironment:\n        env_path = self.data_dir.joinpath(\"venv\")\n        env_path_saved = env_path.with_suffix(\".save\")\n\n        if env_path.exists():\n            self._install_comment(version, \"Saving existing environment\")\n            if env_path_saved.exists():\n                shutil.rmtree(env_path_saved)\n            shutil.move(env_path, env_path_saved)\n\n        try:\n            self._install_comment(version, \"Creating environment\")\n            yield VirtualEnvironment.make(env_path)\n        except Exception as e:\n            if env_path.exists():\n                self._install_comment(\n                    version,\n                    \"An error occurred. Removing partial environment.\",\n                )\n                shutil.rmtree(env_path)\n\n            if env_path_saved.exists():\n                self._install_comment(\n                    version,\n                    \"Restoring previously saved environment.\",\n                )\n                shutil.move(env_path_saved, env_path)\n\n            raise e\n        else:\n            if env_path_saved.exists():\n                shutil.rmtree(env_path_saved, ignore_errors=True)\n\n    def make_bin(self, version: str, env: VirtualEnvironment) -&gt; None:\n        self._install_comment(version, \"Creating script\")\n        self.bin_dir.mkdir(parents=True, exist_ok=True)\n\n        script = \"poetry.exe\" if WINDOWS else \"poetry\"\n        target_script = env.bin_path.joinpath(script)\n\n        if self.bin_dir.joinpath(script).exists():\n            self.bin_dir.joinpath(script).unlink()\n\n        try:\n            self.bin_dir.joinpath(script).symlink_to(target_script)\n        except OSError:\n            # This can happen if the user\n            # does not have the correct permission on Windows\n            shutil.copy(target_script, self.bin_dir.joinpath(script))\n\n    def install_poetry(self, version: str, env: VirtualEnvironment) -&gt; None:\n        self._install_comment(version, \"Installing Poetry\")\n\n        if self._git:\n            specification = \"git+\" + version\n        elif self._path:\n            specification = version\n        else:\n            specification = f\"poetry=={version}\"\n\n        env.pip(\"install\", specification)\n\n    def display_pre_message(self) -&gt; None:\n        kwargs = {\n            \"poetry\": colorize(\"info\", \"Poetry\"),\n            \"DEMO_FOLDER\": colorize(\"comment\", DEMO_FOLDER),\n        }\n        self._write(PRE_MESSAGE.format(**kwargs))\n\n    def display_post_message(self, version: str) -&gt; None:\n        if WINDOWS:\n            return self.display_post_message_windows(version)\n\n        if SHELL == \"fish\":\n            return self.display_post_message_fish(version)\n\n        return self.display_post_message_unix(version)\n\n    def display_post_message_windows(self, version: str) -&gt; None:\n        path = self.get_windows_path_var()\n\n        message = POST_MESSAGE_NOT_IN_PATH\n        if path and str(self.bin_dir) in path:\n            message = POST_MESSAGE\n\n        self._write(\n            message.format(\n                poetry=colorize(\"info\", \"Poetry\"),\n                version=colorize(\"b\", version),\n                poetry_home_bin=colorize(\"comment\", self.bin_dir),\n                poetry_executable=colorize(\"b\", self.bin_dir.joinpath(\"poetry\")),\n                configure_message=POST_MESSAGE_CONFIGURE_WINDOWS.format(\n                    poetry_home_bin=colorize(\"comment\", self.bin_dir),\n                ),\n                test_command=colorize(\"b\", \"poetry --version\"),\n            ),\n        )\n\n    def get_windows_path_var(self) -&gt; str | None:\n        import winreg\n\n        with (\n            winreg.ConnectRegistry(\n                None,\n                winreg.HKEY_CURRENT_USER,\n            ) as root,\n            winreg.OpenKey(root, \"Environment\", 0, winreg.KEY_ALL_ACCESS) as key,\n        ):\n            path, _ = winreg.QueryValueEx(key, \"PATH\")\n\n            return path\n\n    def display_post_message_fish(self, version: str) -&gt; None:\n        fish_user_paths = subprocess.check_output(\n            [\"fish\", \"-c\", \"echo $fish_user_paths\"],\n        ).decode(\"utf-8\")\n\n        message = POST_MESSAGE_NOT_IN_PATH\n        if fish_user_paths and str(self.bin_dir) in fish_user_paths:\n            message = POST_MESSAGE\n\n        self._write(\n            message.format(\n                poetry=colorize(\"info\", \"Poetry\"),\n                version=colorize(\"b\", version),\n                poetry_home_bin=colorize(\"comment\", self.bin_dir),\n                poetry_executable=colorize(\"b\", self.bin_dir.joinpath(\"poetry\")),\n                configure_message=POST_MESSAGE_CONFIGURE_FISH.format(\n                    poetry_home_bin=colorize(\"comment\", self.bin_dir),\n                ),\n                test_command=colorize(\"b\", \"poetry --version\"),\n            ),\n        )\n\n    def display_post_message_unix(self, version: str) -&gt; None:\n        paths = os.getenv(\"PATH\", \"\").split(\":\")\n\n        message = POST_MESSAGE_NOT_IN_PATH\n        if paths and str(self.bin_dir) in paths:\n            message = POST_MESSAGE\n\n        self._write(\n            message.format(\n                poetry=colorize(\"info\", \"Poetry\"),\n                version=colorize(\"b\", version),\n                poetry_home_bin=colorize(\"comment\", self.bin_dir),\n                poetry_executable=colorize(\"b\", self.bin_dir.joinpath(\"poetry\")),\n                configure_message=POST_MESSAGE_CONFIGURE_UNIX.format(\n                    poetry_home_bin=colorize(\"comment\", self.bin_dir),\n                ),\n                test_command=colorize(\"b\", \"poetry --version\"),\n            ),\n        )\n\n    def ensure_directories(self) -&gt; None:\n        self.data_dir.mkdir(parents=True, exist_ok=True)\n        self.bin_dir.mkdir(parents=True, exist_ok=True)\n\n    def get_version(self):\n        current_version = None\n        if self.version_file.exists():\n            current_version = self.version_file.read_text().strip()\n\n        self._write(colorize(\"info\", \"Retrieving Poetry metadata\"))\n\n        metadata = json.loads(self._get(self.METADATA_URL).decode())\n\n        def _compare_versions(x, y):\n            mx = self.VERSION_REGEX.match(x)\n            my = self.VERSION_REGEX.match(y)\n\n            vx = (*tuple(int(p) for p in mx.groups()[:3]), mx.group(5))\n            vy = (*tuple(int(p) for p in my.groups()[:3]), my.group(5))\n\n            if vx &lt; vy:\n                return -1\n            if vx &gt; vy:\n                return 1\n\n            return 0\n\n        self._write(\"\")\n        releases = sorted(\n            metadata[\"releases\"].keys(),\n            key=cmp_to_key(_compare_versions),\n        )\n\n        if self._version and self._version not in releases:\n            msg = f\"Version {self._version} does not exist.\"\n            self._write(colorize(\"error\", msg))\n\n            raise ValueError(msg)\n\n        version = self._version\n        if not version:\n            for release in reversed(releases):\n                m = self.VERSION_REGEX.match(release)\n                if m.group(5) and not self.allows_prereleases():\n                    continue\n\n                version = release\n\n                break\n\n        if current_version == version and not self._force:\n            self._write(\n                f\"The latest version ({colorize('b', version)}) is already installed.\",\n            )\n\n            return None, current_version\n\n        return version, current_version\n\n    def _write(self, line) -&gt; None:\n        sys.stdout.write(line + \"\\n\")\n\n    def _overwrite(self, line) -&gt; None:\n        if not is_decorated():\n            return self._write(line)\n\n        self._cursor.move_up()\n        self._cursor.clear_line()\n        self._write(line)\n\n    def _get(self, url):\n        request = Request(url, headers={\"User-Agent\": \"Python Poetry\"})\n\n        with closing(urlopen(request)) as r:\n            return r.read()\n</code></pre>"},{"location":"reference/#framdemo.install_poetry.Installer.install","title":"<code>install(version)</code>","text":"<p>Installs Poetry in $POETRY_HOME.</p> Source code in <code>framdemo/install_poetry.py</code> <pre><code>def install(self, version):\n    \"\"\"\n    Installs Poetry in $POETRY_HOME.\n    \"\"\"\n    self._write(\n        \"Installing {} ({})\".format(\n            colorize(\"info\", \"Poetry\"),\n            colorize(\"info\", version),\n        ),\n    )\n\n    with self.make_env(version) as env:\n        self.install_poetry(version, env)\n        self.make_bin(version, env)\n        self.version_file.write_text(version)\n        self._install_comment(version, \"Done\")\n\n        return 0\n</code></pre>"},{"location":"what_demo_includes/","title":"What the demo case includes","text":"<p>The demo case includes 2 model runs:</p> <ul> <li>northern Europe aggregated (endogenous and exogenous regions)</li> <li>Nordic countries (Norway, Sweden, Finland, Denmark) more detailed (namely more detailed hydropower) using prices from the previous model run.</li> </ul> <p>The following countries are included in the demo case: </p> Countries included Modelling - 1st model run Modelling - 2nd model run Norway endogenous/aggregated endogenous/dissaggregated Sweden endogenous/aggregated endogenous/dissaggregated Finland endogenous/aggregated endogenous/dissaggregated Denmark endogenous/aggregated endogenous/dissaggregated Netherlands endogenous/aggregated exogenous Germany endogenous/aggregated exogenous UK endogenous/aggregated exogenous Poland endogenous/aggregated exogenous Lithuania endogenous/aggregated exogenous Estonia endogenous/aggregated exogenous Latvia exogenous not included France exogenous not included Belgium exogenous not included Switzerland exogenous not included Austria exogenous not included Czech Republic exogenous not included Slovakia exogenous not included <p>Both model runs are a series-simulation (...)</p>"}]}